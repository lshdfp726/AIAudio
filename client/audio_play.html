<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>ESP32-S3降噪音频播放器（优化停顿版）</title>
    <style>
        body { font-family: Arial, sans-serif; text-align: center; }
        #status { color: #666; margin: 20px 0; }
        .controls { margin: 20px 0; }
        .filter-controls { margin: 10px 0; padding: 10px; border: 1px solid #eee; max-width: 600px; margin: 0 auto; }
        #debug { color: #999; font-size: 12px; text-align: left; max-width: 600px; margin: 0 auto; }
        .buffer-status { color: #333; font-size: 14px; margin: 10px 0; }
    </style>
</head>
<body>
    <h1>ESP32-S3降噪音频播放器</h1>
    <button id="playBtn">开始播放</button>
    <div id="status">未连接</div>
    <!-- 新增：缓冲区状态显示，便于调试 -->
    <div class="buffer-status">
        缓冲区大小: <span id="bufferSize">0ms</span> | 播放延迟: <span id="playDelay">0ms</span>
    </div>
    
    <div class="filter-controls">
        <h3>降噪控制</h3>
        <label>高频降噪强度: 
            <input type="range" id="noiseReduction" min="0" max="1" step="0.1" value="0.5">
            <span id="nrValue">0.5</span>
        </label>
        <label>风噪过滤: 
            <input type="checkbox" id="windFilter" checked>
        </label>
    </div>

    <div id="debug"></div>

    <script type="module">
        import AudioStorage from './audio-storage.js';
        const audioStorage = new AudioStorage();
        let audioContext = null;
        let socket = null;
        let isPlaying = false;
        let audioQueue = [];
        let lastPlayTime = 0;
        const MAX_QUEUED_CHUNKS = 10; // 最多缓存10个音频块
        const SAMPLE_RATE = 16000;
        
        // 新增：缓冲区参数（关键优化）
        const TARGET_BUFFER_DURATION = 0.3; // 目标缓冲区大小（300ms，平衡延迟和稳定性）
        const MIN_BUFFER_DURATION = 0.1;    // 最小安全缓冲区（低于此值可能停顿）
        
        // 降噪参数
        let noiseReduction = 0.5;
        let windFilterEnabled = true;
        
        // 音频处理节点
        let gainNode = null;
        let highpassFilter = null;
        let lowpassFilter = null;
        
        // DOM元素
        const playBtn = document.getElementById('playBtn');
        const statusEl = document.getElementById('status');
        const noiseReductionSlider = document.getElementById('noiseReduction');
        const nrValueEl = document.getElementById('nrValue');
        const windFilterCheckbox = document.getElementById('windFilter');
        const debugEl = document.getElementById('debug');
        // 新增：缓冲区状态元素
        const bufferSizeEl = document.getElementById('bufferSize');
        const playDelayEl = document.getElementById('playDelay');

        // 调试日志
        function debugLog(msg) {
            console.log(msg);
            debugEl.textContent = msg + '\n' + debugEl.textContent;
            if (debugEl.textContent.split('\n').length > 30) {
                debugEl.textContent = debugEl.textContent.split('\n').slice(-30).join('\n');
            }
        }

        // 初始化音频上下文和滤波器
        function initAudioContext() {
            if (!audioContext) {
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: SAMPLE_RATE });
                } catch (e) {
                    // 若不支持，使用默认采样率，但记录下来
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                // 打印实际采样率，验证是否为16000Hz
                console.log("实际播放采样率：", audioContext.sampleRate); // 关键！若不是16000，需处理
                // 创建音频处理节点链
                gainNode = audioContext.createGain();
                gainNode.gain.value = 0.7;
                
                //高通滤波 ，高于100HZ的正常通过，低于100 的进行衰减
                highpassFilter = audioContext.createBiquadFilter();
                highpassFilter.type = 'highpass';
                highpassFilter.frequency.value = 100;
                highpassFilter.Q.value = 0.707;
                //低通滤波，低于8000的正常通过，高于8000的进行衰减
                lowpassFilter = audioContext.createBiquadFilter();
                lowpassFilter.type = 'lowpass';
                lowpassFilter.frequency.value = 8000;
                lowpassFilter.Q.value = 0.707;
                
                // 连接处理链
                highpassFilter.connect(lowpassFilter);
                lowpassFilter.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                debugLog('音频上下文及滤波器初始化完成');
            }
        }

        // 动态噪声过滤
        function applyNoiseReduction(pcmData) {
            if (noiseReduction <= 0) return pcmData;
            
            const filtered = new Int16Array(pcmData.length);
            const threshold = 50 * (1 - noiseReduction);
            
            for (let i = 0; i < pcmData.length; i++) {
                const value = pcmData[i];
                if (Math.abs(value) < threshold) {
                    filtered[i] = Math.round(value * (Math.abs(value) / threshold) * (1 - noiseReduction));
                } else {
                    filtered[i] = value;
                }
            }
            return filtered;
        }

        // 新增：计算当前缓冲区大小（秒）
        function getBufferDuration() {
            const totalSamples = audioQueue.reduce((sum, chunk) => sum + chunk.length, 0);
            return totalSamples / SAMPLE_RATE;
        }

        // 新增：更新缓冲区状态显示
        function updateBufferStatus() {
            const bufferDuration = getBufferDuration();
            bufferSizeEl.textContent = `${Math.round(bufferDuration * 1000)}ms`;
            
            const now = audioContext.currentTime;
            const delay = Math.max(0, lastPlayTime - now);
            playDelayEl.textContent = `${Math.round(delay * 1000)}ms`;
            
            // 缓冲区过低时预警
            if (bufferDuration < MIN_BUFFER_DURATION) {
                bufferSizeEl.style.color = 'red';
                debugLog(`警告：缓冲区过低（${bufferDuration.toFixed(2)}s），可能停顿`);
            } else {
                bufferSizeEl.style.color = 'inherit';
            }
        }

        // 处理音频队列（核心优化）
        function processAudioQueue() {
            if (audioContext.state !== 'running') {
                audioContext.resume();
            }
            
            // 新增：根据缓冲区大小决定是否处理（避免频繁处理小帧）
            const bufferDuration = getBufferDuration();
            
            // 只有当缓冲区达到目标大小，或接近耗尽时才处理（减少处理次数）
            if (bufferDuration >= TARGET_BUFFER_DURATION || bufferDuration < MIN_BUFFER_DURATION) {
                const totalLength = audioQueue.reduce((len, chunk) => len + chunk.length, 0);
                if (totalLength === 0) return;
                
                // 合并队列数据
                const merged = new Int16Array(totalLength);
                let offset = 0;
                audioQueue.forEach(chunk => {
                    merged.set(chunk, offset);
                    offset += chunk.length;
                });
                audioQueue = []; // 清空队列
                
                // 应用降噪
                const denoisedData = applyNoiseReduction(merged);
                
                // 创建音频缓冲区
                const buffer = audioContext.createBuffer(1, denoisedData.length, SAMPLE_RATE);
                const floatData = buffer.getChannelData(0);
                for (let i = 0; i < denoisedData.length; i++) {
                    floatData[i] = denoisedData[i] / 32768; //归一化，16位有符号数据范围是-(2^16 - 1) ~ 2^16
                }
                
                // 创建音频源
                const source = audioContext.createBufferSource();
                source.buffer = buffer;
                
                // 连接滤波器
                if (windFilterEnabled) {
                    source.connect(highpassFilter);
                } else {
                    source.connect(lowpassFilter);
                }
                
                // 新增：精确计算播放时间（避免间隙）
                const now = audioContext.currentTime;
                // 确保播放时间不早于当前时间，且平滑衔接上一帧
                lastPlayTime = Math.max(now, lastPlayTime);
                source.start(lastPlayTime);
                lastPlayTime += buffer.duration;
                
                debugLog(`处理音频帧（${merged.length}样本，时长${buffer.duration.toFixed(2)}s）`);
            }
            
            // 更新状态
            updateBufferStatus();
        }

        // WebSocket连接（优化数据接收逻辑）
        function connectWebSocket() {
            const esp32Ip = "192.168.0.105";
            socket = new WebSocket(`ws://${esp32Ip}:12345`);
            socket.binaryType = 'arraybuffer';

            socket.onopen = () => {
                //清楚历史音频
                audioStorage.clearAllAudioRecords();

                statusEl.textContent = '已连接，正在接收音频...';
                playBtn.textContent = '停止播放';
                isPlaying = true;
                audioQueue = [];
                // 新增：初始播放时间设置（预留缓冲时间）
                lastPlayTime = audioContext.currentTime + TARGET_BUFFER_DURATION;
                debugLog('WebSocket连接成功，初始化缓冲区...');
            };

            socket.onmessage = (event) => {
                if (event.data instanceof ArrayBuffer) {
                    audioStorage.storeAudioData(event.data, {
                        format: 'pcm',
                        sampleRate: 16000,
                        timestamp: new Date().toISOString()
                    }).then(recordId => {
                        // 可以在这里更新UI显示存储状态
                        console.log(`已存储音频片段，ID: ${recordId}`);
                    }).catch(error => {
                        console.error('存储失败:', error);
                    });
                }
                return ;
                // 解析数据
                // const int32Data = new Int32Array(event.data);
                // const pcmData = new Int16Array(int32Data.length);

                // for (let i = 0; i < int32Data.length; i++) {
                //     const sample24bit = int32Data[i] >> 8;
                //     pcmData[i] = (sample24bit >> 8) & 0xFFFF;
                // }
                const pcmData = new Int16Array(event.data);

                // 限制队列长度，避免内存溢出
                if (audioQueue.length >= MAX_QUEUED_CHUNKS) {
                    debugLog("警告：缓冲区已满，丢弃 oldest chunk");
                    audioQueue.shift(); // 丢弃最早的块
                }

                // 添加到队列
                audioQueue.push(pcmData);
                
                // 新增：仅在缓冲区足够或过低时处理（减少处理频率）
                const bufferDuration = getBufferDuration();
                if (bufferDuration >= TARGET_BUFFER_DURATION || bufferDuration < MIN_BUFFER_DURATION) {
                    // 使用requestIdleCallback避免阻塞主线程（关键优化）
                    requestIdleCallback(processAudioQueue, { timeout: 50 });
                }
                
                // 更新状态
                updateBufferStatus();
            };

            socket.onclose = () => {
                statusEl.textContent = '连接已关闭，3秒后重连';
                playBtn.textContent = '开始播放';
                isPlaying = false;
                setTimeout(connectWebSocket, 3000);
            };

            socket.onerror = (error) => {
                debugLog(`WebSocket错误: ${error}`);
            };
        }

        // 初始化滤波器链
        function initFilters() {
            highpassFilter = audioContext.createBiquadFilter();
            highpassFilter.type = 'highpass';
            highpassFilter.frequency.value = 100;
            highpassFilter.Q.value = 0.707;
            
            lowpassFilter = audioContext.createBiquadFilter();
            lowpassFilter.type = 'lowpass';
            lowpassFilter.frequency.value = 8000;
            lowpassFilter.Q.value = 0.707;
            
            // 重新连接滤波器链
            highpassFilter.connect(lowpassFilter);
            lowpassFilter.connect(gainNode);
        }

        // 事件监听
        noiseReductionSlider.addEventListener('input', (e) => {
            noiseReduction = parseFloat(e.target.value);
            nrValueEl.textContent = noiseReduction.toFixed(1);
        });

        windFilterCheckbox.addEventListener('change', (e) => {
            windFilterEnabled = e.target.checked;
        });

        playBtn.addEventListener('click', () => {
            if (isPlaying) {
                // 停止播放
                if (socket) socket.close();
                isPlaying = false;
                statusEl.textContent = '已停止';
                playBtn.textContent = '开始播放';
            } else {
                // 开始播放：确保音频上下文初始化
                initAudioContext();
                initFilters();
                connectWebSocket();
            }
        });
    </script>
</body>
</html>